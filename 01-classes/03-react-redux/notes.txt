React Hooks

#58 - useState
-> const [num, setNum] useState(0)
-> adiciona uma estado a um componente

#60 - useEffect
-> useEffect(EffectCallback, DependencyList)
-> execulta uma callback quando um valor na "DependencyList" é 
alterado

# 63 - useRef
-> useRef.current 
-> retornar o mesmo objeto como referencia a cada rederização
-> não dispara uma nova renderização quando alterado

# 64 - useRef
-> propriedade (ref) do componente

    const inputRef = useRef(null)
    <input  ref={inputRef} /> 
    
-> inputRef.current === (Elemento "input" )

#65 - ?? DESAFIO

66 - UseMemo
-> useMeno(callback, dependencyList)
retorna um valor memorizado

-> useEffect / useMemo

useEffect(() => {
   setResult( sum(n1, n2))
},  [n1, n2])

const result = useMeno(() => sum(n1,  n2), [n1, n2])

#67 - useCallback / React.memo

-> React.memo (useMeno)
pode ser usado para evitar a rederização repetida de componentes estáticos

-> useCallback 
retorna sempre a mesma referência a função passada por
parâmetro

const [Count, setCount] = useState(0)

const inc = useCallback(function (delta)){
    setCount(current => current + delta)
}, [setCount])


#68 - Context API 
utilizado para compartilhar informações entre componentes de
forma direta, sem a necessidade de percorrer a árvore de 
componentes.

#69 - React.useContext()
/DataContext.js

    export const data =  {
        number: 123,
        text: "Context API" 
    }

    export default DataContext

/App.jsx

    import DataContext, {data} from "DataContext.js"
    
    const [state, setState] = React.useState(data)
    return (
        <DataContext.Provider value={ {state, setState } }
            "Components"
        </DataContext.Provider>
    )
 
 /UseContext.jsx
 
    import DataContext, {data} from "DataContext.js"
 
     const {state, setState} = React.useContext(DataContext)
     
    function addNumber(delta) {
        setState({
            ...state,
            number: state.number + delta
        })
    }
 
#70 - React.useContext( )

#71 - React.useReducer( ) 

// estado inicial da aplicação
const  initialState = {
    cart: [],
    products: [],
    use: null,
    number: 0
}

// controlando o objeto "action"
function reducer(state, action){

    switch(action.type){
    
        case "number_add2":
            return {...state, number: state.number + 2}
            
        default:
            return state
    }
}

const [state, dispatch] = useReduce(reduce, initialState)

<button onClick={( ) => dispatch({ type:  "numberAdd2"  })} >
    +2
</button> 

#72 - Desafio ???

#73 - Desafio ???

#74 -.useReducer( )

#75 - CUSTOM HOOK

 /hooks/useCounter.js
export const useCounter = (initialValue = 100) => {
    const [count, setCount] = useState(initialValue)
    
    function inc( ) {
        set count(count + 1)
    }

    function dec() {
        setCount(count - 1)
    }
    return [count, inc, dec ]
}


/hooks/useCustom.jsx

const [count, inc, dec] = useCounter()
 
#76 CUSTOM HOOK #2

/hooks/useFetch.js

export const useFetch = (url, method = "get") => {
    const [response, setResponse] = useState({ 
        data: null,
        loading: true   
     })
     
     useEffect(function (){
        fetch(url, { method })
            .then(resp => resp.json())
            .then(json => setResponse({
                data: json,
                loading: false
            }))
     }, [url, method])
     
     return response
}

/useCustom.jsx

const url = "http://files. ... .json"
const response = useFetch(url)

function showState(state){
    return states.map(state => (
    <li key={state.nome}>
        {state.nome } - {state.sigla}
    </li>
    )
}

return (
    ...
    <ul>
        {response.data ? showState() : false}
    </ul>
)


#77 
















